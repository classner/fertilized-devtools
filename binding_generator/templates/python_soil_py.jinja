## Author: Christoph Lassner.
{% include 'python_disclaimer.jinja' %}
{% import 'pythontools.jinja' as pytools %}

r"""
Presents a convenience wrapper for the pyfertilized module.

This wrapper offers meaningful method signatures, docstrings, and most
important, the `Soil` class, that offers the possibility to specify once
the datatypes and then generate objects that can work with the according
data.

This file is automatically generated!
"""
from fertilized.TypeTranslations import _dtype_str_translation
import os
import pyfertilized_vec as _pyfertilized_vec

def import_by_name(name):
    mod = __import__(name)
    components = name.split('.')
    for comp in components[1:]:
        mod = getattr(mod, comp)
    return mod

_part_id = 0
_pyfertilized = []
while True:
    try:
        _pyfertilized.append(import_by_name('fertilized.pyfertilized_%d' % (_part_id)))
    except Exception as ex:
        break
    _part_id += 1
import pyfertilized_mf as _pyfertilized_mf

def _enum(*sequential, **named):
    enums = dict(zip(sequential, range(len(sequential))), **named)
    reverse = dict((value, key) for key, value in list(enums.iteritems()))
    enums['reverse_mapping'] = reverse
    enums['keys'] = range(len(sequential))
    return type('Enum', (), enums)

__all__ = ["Soil", "Result_Types", "_pyfertilized", "_pyfertilized_mf"]

Result_Types = _enum('probabilities',
                     'hough_map',
                     'regression')

_res_type_str_translation = { Result_Types.probabilities:["fv","fv"],
                              Result_Types.hough_map:["hp", "vhp"],
                              Result_Types.regression:["rp","vprpf"]}

# Default initializations.
_DEFAULT_ENTROPY_VEC_2 = ['induced', 'induced']
_DEFAULT_ENTROPY_P1_2 = [2., 1.1]

class Soil:
  r"""
  Convenience factory class for creating forest objects of specified types.

  You can create a `Soil` once with a given set of types that you want to
  work with. All following objects constructed by the soil objects work
  with according types, so that you don't have to worry about this detail.

  All these objects can be found in the `pyfertilized`-module, but they
  have unhandy, long names and it is necessary to repeatedly find the
  correct object with the proper name.

  Take into account, that not all objects can be created by a `Soil` of a
  specific type! Calling the respective functions throws an exception.

  The datatype strings are translated into an internal string representation,
  so they can be specified quite freely, e.g. specyfing `f` or `float` is
  both understood as `float`. Take into account, that these datatypes are
  interpreted like the C++ datatypes, i.e. `float` is (usually) a 32-bit
  floating point number, and `double` is (usually) the 64-bit counterpart
  as opposed to python that doesn't know 32-bit floats and calls 64-bit
  floating point numbers `float`.

  There is the enum `Result_Types` available in this package, that provides
  access to the different result types.

  Example usage:

  >>> soil = Soil(result_type=Result_Types.probabilities)
  >>> leaf_manager = soil.ClassificationLeafManager(2)
  <fertilized.pyfertilized.ClassificationLeafManager_f_uint at 0x7c849a8>

  A leaf manager working with the proper types (in this case
  `float` and `unsigned int`) has been created.
  """
  def __init__(self, input_dtype_str='float',
                     feature_dtype_str='float',
                     annotation_dtype_str='uint',
                     result_type=Result_Types.probabilities):
    if input_dtype_str in _dtype_str_translation:
      self._inp_str = _dtype_str_translation[input_dtype_str]
    else:
      raise Exception("Unknown input dtype string! Knwon strings are: " +\
                      ', '.join(_dtype_str_translation.keys()))
    if feature_dtype_str in _dtype_str_translation:
      self._feat_str = _dtype_str_translation[feature_dtype_str]
    else:
      raise Exception("Unknown feature dtype string! Knwon strings are: " +\
                      ', '.join(_dtype_str_translation.keys()))
    if annotation_dtype_str in _dtype_str_translation:
      self._ann_str = _dtype_str_translation[annotation_dtype_str]
    else:
      raise Exception("Unknown annotation dtype string! Knwon strings are: " +\
                      ', '.join(_dtype_str_translation.keys()))
    self._res_type = result_type
    if self._res_type == Result_Types.regression:
      self._tres = _res_type_str_translation[result_type][0] + self._inp_str
      self._fres = _res_type_str_translation[result_type][1] + self._inp_str
    elif self._res_type == Result_Types.probabilities or \
         self._res_type == Result_Types.hough_map:
      self._tres = _res_type_str_translation[result_type][0]
      self._fres = _res_type_str_translation[result_type][1]
    else:
      raise Exception("Unknown result type!")

@ for class in classes
@   for constructor in class.Constructors
@     if 'Python' in constructor.AvailableIn
@       if not constructor.ExportedName is none
  def {{constructor.ExportedName}}(self,
@       else
  def {{class.ClassName}}(self,
@       endif
        {{pytools.render_arguments(constructor)}}           ):
{{constructor.Documentations['Python'].render_at(4, prepend=('Class information:\n*==================\n*\n*' + class.Documentations['C++'][5:-2]+'\n*Constructor:\n*============\n*\n*'))}}
    attrname = '{{class.ClassName}}{%if not class.ClassType.TemplateParams is none%}{%for arg in class.ClassType.TemplateParams%}_%s{%endfor%}{%endif%}' % ({{pytools.render_template_args_to_soil(class)}})
    cons_method = None
    for part_mod in _pyfertilized:
        if hasattr(part_mod, attrname):
            cons_method = part_mod.__dict__[attrname]
            break
    if cons_method is None:
      raise Exception("This object is not supported by the current Soil (pyfertilized.%s)!" % (attrname))
    obj = cons_method({{pytools.render_arguments(constructor, render_defaults=False)}}          )
    return obj

@     endif
@   endfor
@ endfor

@ for func in functions
@   if not func.ExportedName is none
  def {{func.ExportedName}}(self,
@   else
  def {{func.FunctionPrefix}}(self,
@   endif
      {{pytools.render_arguments(func)}}          ):
{{func.Documentations['Python'].render_at(4)}}
    attrname = '{{func.FunctionPrefix}}{%if not func.TemplateArguments is none %}{%for arg in func.TemplateArguments%}_%s{%endfor%}{%endif%}' % ({{pytools.render_func_template_args_to_soil(func)}})
    if not hasattr(_pyfertilized_mf, attrname):
      raise Exception("This function is not supported by the current Soil (pyfertilized_mf.%s)!" % (attrname))
    exec_obj = _pyfertilized_mf.__dict__[attrname]
    return exec_obj({{pytools.render_arguments(func, render_defaults=False)}}          )

@ endfor
